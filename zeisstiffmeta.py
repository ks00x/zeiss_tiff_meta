"""
import metadata from a zeiss SEM tiff file
requires the tifffile library ( pip install tifffile )
Created on Tue Aug 28 14:18:03 2018
@author: scp
"""

import pathlib
from tifffile import TiffFile,imsave,imread,imwrite
import io
import logging
logger = logging.getLogger(__name__)


def zeiss_meta(file='demodemo.tif') :
    '''
    returns the metadata as a list of 4-element tuples ('exifkey','parameter','value','unit')
    'exifkey' is a technical name of the item without blanks (defined by Zeiss)
    'parameter' is a more human readable translation of exifkey (defined by Zeiss)
    'value' can be numerical or a string
    'unit' is a string describing the physical unit such as 'uA' , 'V' , 'mm' 
    '''
    logger.debug(f'zeiss_meta({file})')
    
    if file == 'demodemo.tif' :
        #load some demo data
        import os
        path = os.path.abspath(__file__)
        dir_path = os.path.dirname(path)
        file = dir_path + '\\test.tif'
    elif isinstance(file,io.BytesIO) :        
        f = file        
    else :
        f = pathlib.Path(file)
    try:
        with TiffFile(f) as t :
            if hasattr(t,'sem_metadata') == True :
                sem = t.sem_metadata
            else :
                print('there is no Zeiss SEM metadata')
                return(None)
        tab=[]
    
        for key,val in sem.items() :
            try :
                unit = val[2]
            except :
                unit=''
            tab.append((key,val[0],val[1],unit))
        tab.append(('__filename','__filename',str(file),''))        
    except Exception as e:
        print('error reading file:',str(file))
        print(e)
        return(None)

    return( tab )
# zeiss_meta

# the vip filter list for reducing the metadata
vip = ['Detector','Store resolution','Stage at X','Stage at Y',
       'Pixel Size','EHT','I Probe','Mag','WD','Beam Offset X','Beam Offset Y',
       'Beam Shift Align X','Beam Shift Align Y',
      'Stage at R','Stage at M','Stage at T','Stage at Z',
      'Gun Vacuum','System Vacuum','__filename']


def meta_to_dict(tab) :
    '''
    tranforms the metadata list into a dict filtering vip list entries only
    numeric values are converted to SI units (m,s,A, etc)
    width,height (in m) , xpts , ypts entries are added for convienence
    '''
    # this dict is needed to convert the values to SI using the separate units column
    utonum = {'pA':1e-12,'nA':1e-9,'µA':1e-6,'pm':1e-12,'nm':1e-9,'µm':1e-6,
              'mm':1e-3,'V':1.0,'kV':1e3,'K X':1e3}

    d = {x[1]:(x[2],x[3]) for x in tab if x[1] in vip}
    # convert to SI units using the units column:
    m = {}
    for xx in d.items() :
        if xx[1][1] in utonum :
            m[xx[0]] = xx[1][0] * utonum[xx[1][1]]                                
        else :
            m[xx[0]] = xx[1][0]        
    s = m['Store resolution'].split('*')
    m['xpts'] = int(s[0])
    m['ypts'] = int(s[1])
    # there seems to be a bug with high res images:
    m['Pixel Size'] = m['Pixel Size'] * 1024 / m['xpts']    
    if isinstance(m['Mag'], str) and 'K X' in m['Mag'] : # translate the 'K X' strings to a floating nunmber
        m['Mag'] = float(m['Mag'].split(' ')[0]) * 1000.0
    elif m['Mag'] != '' :        
        m['Mag'] = float(m['Mag'])
    #m['filename'] = str(f)
    m['width'] = m['xpts'] * m['Pixel Size']
    m['height'] = m['ypts'] * m['Pixel Size']
    return( m )


def meta_to_dict_all(tab) :
    """[tranforms the full metadata array into a dict without filtering
        numeric values are converted to SI units (m,s,A, etc)
        width,height (in m) , xpts , ypts entries are added for convienence]
    
    Arguments:
        tab {[list]} -- [metadata list generated by zeiss_meta]
    """
    
    # this dict is needed to convert the values to SI using the separate units column
    utonum = {'pA':1e-12,'nA':1e-9,'µA':1e-6,'pm':1e-12,'nm':1e-9,'µm':1e-6,
              'mm':1e-3,'V':1.0,'kV':1e3,'K X':1e3}

    d = {x[1]:(x[2],x[3]) for x in tab[2:-1]}
    # convert to SI units using the units column:
    m = {}
    for xx in d.items() :
        if xx[1][1] in utonum :
            m[xx[0]] = xx[1][0] * utonum[xx[1][1]]                                
        else :
            m[xx[0]] = xx[1][0]        
    s = m['Store resolution'].split('*')
    m['xpts'] = int(s[0])
    m['ypts'] = int(s[1])
    # there seems to be a bug with high res images:
    m['Pixel Size'] = m['Pixel Size'] * 1024 / m['xpts']
    if isinstance(m['Mag'], str) and 'K X' in m['Mag'] : # translate the 'K X' strings to a floating nunmber
        m['Mag'] = float(m['Mag'].split(' ')[0]) * 1000.0
    elif m['Mag'] != '' :        
        m['Mag'] = float(m['Mag'])    
    #m['filename'] = f
    m['width'] = m['xpts'] * m['Pixel Size']
    m['height'] = m['ypts'] * m['Pixel Size']
    return( m )



# src = 'y:/data import/SEM\\2017-01-24 Mirro aligned6.tif'
# tab = zeiss_meta(src)
# m = meta_to_dict(tab)
# print(m)



def zeissconvert(srcpath,destpath,fullmeta=False) :
    '''
    convert a Zeiss SEM tif file so that the new file
    has dpi correctly set and ImageJ has the scaling in um
    Reduced metadata is written to the subject field
    '''
    srcpath = pathlib.Path(srcpath)
    destpath = pathlib.Path(destpath)
    logger.debug(f'zeiss_convert({srcpath},{destpath})')

    try :                
        # get the metadata from the original file 
        tab = zeiss_meta(srcpath)
        if fullmeta == True :
            m = meta_to_dict_all(tab)
        else :
            m = meta_to_dict(tab)
        # we have to specify res as pixels/cm
        r = 1.0 / (m['Pixel Size']*100.0)
        r = int(r) # imsave freeks out otherwise...
        res =(r,r,'CENTIMETER')
        # ImageJ gets this ok, but for SEM um or nm units would be more approriate...
        # ImageJ does not automatically change the pixels per unit when changing the unit
        # We could save like this but precalculate pixels/um ... (hack)
        print(m)
        im = imread(str(srcpath))
        imsave(str(destpath),im,compress=6,resolution=res,metadata=m)
        #imwrite(str(destpath),im,compress=6,resolution=res)
        # metadata written this way end up in the subject area...                              
        return(True)
    except Exception as e:
        logger.error(f'zeiss_convert({srcpath},{destpath})')
        raise Exception('error in zeissconvert')
        
def read_image(file):
    tf = TiffFile(file)    
    return tf.asarray()


if __name__ == "__main__":

    logging.basicConfig(level=logging.DEBUG)
    t = zeiss_meta('test.tif')
    m = meta_to_dict(t)    
    for key,val in m.items():
        print(f'{key} = {val}')


    zeissconvert('test1.tif','test_converted.tif')
